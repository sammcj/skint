package launcher

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"syscall"

	"github.com/sammcj/skint/internal/config"
	"github.com/sammcj/skint/internal/providers"
)

// Launcher handles spawning Claude with the correct environment
type Launcher struct {
	config  *config.Config
	dataDir string
}

// New creates a new launcher
func New(cfg *config.Config) (*Launcher, error) {
	dataDir, err := config.GetDataDir()
	if err != nil {
		return nil, fmt.Errorf("failed to get data directory: %w", err)
	}

	return &Launcher{
		config:  cfg,
		dataDir: dataDir,
	}, nil
}

// Launch launches Claude with the specified provider
func (l *Launcher) Launch(provider providers.Provider, args []string) error {
	// Validate provider
	if err := provider.Validate(); err != nil {
		return fmt.Errorf("provider validation failed: %w", err)
	}

	// Check if claude command exists
	claudePath, err := exec.LookPath("claude")
	if err != nil {
		return fmt.Errorf("claude command not found. Please install Claude Code: https://claude.ai/install.sh")
	}

	// Build environment
	env := l.buildEnvironment(provider)

	// Show banner if enabled and not disabled via env
	if !l.config.NoBanner && os.Getenv("SKINT_NO_BANNER") != "1" {
		l.showBanner(provider)
	}

	// Launch Claude
	return l.exec(claudePath, args, env)
}

// buildEnvironment builds the environment variables for Claude
func (l *Launcher) buildEnvironment(provider providers.Provider) []string {
	// Start with current environment
	env := os.Environ()

	// Remove existing Anthropic variables to avoid conflicts
	env = l.removeEnvVars(env, "ANTHROPIC_BASE_URL", "ANTHROPIC_AUTH_TOKEN",
		"ANTHROPIC_API_KEY", "ANTHROPIC_MODEL", "ANTHROPIC_DEFAULT_HAIKU_MODEL",
		"ANTHROPIC_DEFAULT_SONNET_MODEL", "ANTHROPIC_DEFAULT_OPUS_MODEL",
		"ANTHROPIC_SMALL_FAST_MODEL")

	// Remove OpenAI variables to avoid conflicts with custom OpenAI providers
	env = l.removeEnvVars(env, "OPENAI_BASE_URL", "OPENAI_API_KEY", "OPENAI_MODEL")

	// Add provider-specific variables
	providerVars := provider.GetEnvVars()
	for key, value := range providerVars {
		env = append(env, fmt.Sprintf("%s=%s", key, value))
	}

	return env
}

// removeEnvVars removes specified environment variables
func (l *Launcher) removeEnvVars(env []string, vars ...string) []string {
	varNames := make(map[string]bool)
	for _, v := range vars {
		varNames[v] = true
	}

	var result []string
	for _, e := range env {
		name, _, ok := strings.Cut(e, "=")
		if !ok {
			// Entry without '=' -- preserve it
			result = append(result, e)
			continue
		}
		if !varNames[name] {
			result = append(result, e)
		}
	}

	return result
}

// showBanner displays the Skint banner
func (l *Launcher) showBanner(provider providers.Provider) {
	// Read banner file if it exists
	bannerFile := filepath.Join(l.dataDir, "banner")
	if data, err := os.ReadFile(bannerFile); err == nil {
		fmt.Fprint(os.Stderr, string(data))
	} else {
		// Default banner
		fmt.Fprintln(os.Stderr, "  ____ _       _   _")
		fmt.Fprintln(os.Stderr, " / ___| | ___ | |_| |__   ___ _ __")
		fmt.Fprintln(os.Stderr, "| |   | |/ _ \\| __| '_ \\ / _ \\ '__|")
		fmt.Fprintln(os.Stderr, "| |___| | (_) | |_| | | |  __/ |")
		fmt.Fprintln(os.Stderr, " \\____|_|\\___/ \\__|_| |_|\\___|_|")
	}

	fmt.Fprintf(os.Stderr, "    + %s\n\n", provider.DisplayName())
}

// exec executes Claude with the given environment
func (l *Launcher) exec(claudePath string, args []string, env []string) error {
	if runtime.GOOS == "windows" {
		// Windows doesn't support syscall.Exec, use exec.Command
		cmd := exec.Command(claudePath, args...)
		cmd.Env = env
		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		return cmd.Run()
	}

	// Unix: Use syscall.Exec to replace current process
	// This is important so signals are properly passed to Claude
	return syscall.Exec(claudePath, append([]string{"claude"}, args...), env)
}

// LaunchNative launches Claude without any provider env var overrides.
// Used when the active provider is "native" (direct Anthropic).
func (l *Launcher) LaunchNative(args []string) error {
	claudePath, err := exec.LookPath("claude")
	if err != nil {
		return fmt.Errorf("claude command not found. Please install Claude Code: https://claude.ai/install.sh")
	}

	env := os.Environ()
	return l.exec(claudePath, args, env)
}

// CheckClaude verifies that Claude CLI is installed
func CheckClaude() error {
	_, err := exec.LookPath("claude")
	if err != nil {
		return fmt.Errorf("claude command not found. Please install Claude Code first:\n  curl -fsSL https://claude.ai/install.sh | bash")
	}
	return nil
}

// GenerateScript generates a shell script for the provider (backward compatibility)
func GenerateScript(provider providers.Provider, binDir string) error {
	name := provider.Name()
	scriptPath := filepath.Join(binDir, fmt.Sprintf("skint-%s", name))

	// Build script content
	script := fmt.Sprintf(`#!/usr/bin/env bash
# Generated by Skint - Multi-provider launcher for Claude CLI
set -euo pipefail

# Show banner
if [[ "${SKINT_NO_BANNER:-}" != "1" && -t 1 ]]; then
  cat "${XDG_DATA_HOME:-$HOME/.local/share}/skint/banner" 2>/dev/null || echo "  ____ _       _   _"
  echo "    + %s"
  echo
fi

# Load secrets if they exist
SECRETS="${XDG_DATA_HOME:-$HOME/.local/share}/skint/secrets.env"
if [[ -f "$SECRETS" ]]; then
  [[ -L "$SECRETS" ]] && { echo "Error: secrets file is a symlink" >&2; exit 1; }
  source "$SECRETS"
fi

# Set environment variables
`, provider.DisplayName())

	// Add provider-specific exports
	envVars := provider.GetEnvVars()
	for key, value := range envVars {
		if value == "" {
			script += fmt.Sprintf("export %s=\"\"\n", key)
		} else {
			script += fmt.Sprintf("export %s=%q\n", key, value)
		}
	}

	// Add exec claude
	script += `
exec claude "$@"
`

	// Ensure bin directory exists
	if err := os.MkdirAll(binDir, 0755); err != nil {
		return fmt.Errorf("failed to create bin directory: %w", err)
	}

	// Write script
	if err := os.WriteFile(scriptPath, []byte(script), 0755); err != nil {
		return fmt.Errorf("failed to write script: %w", err)
	}

	return nil
}

